{"compress":true,"commitItems":[["4147cd23-172f-41ab-aaa5-805b24898f36",1548241156300,"# Z-2 作用域与闭包\n\n[TOC]\n\n## 1.什么是作用域\n\n几乎所有语言的**最基础模型之一**就是**在变量中存储值**，并且**在稍后取出或修改这些值的能力**。事实上，**在变量中存储值和取出值的能力，给程序赋予了 *状态*。**\n\n但是在我们的程序中纳入变量，引出了我们现在将要解决的最有趣的问题：这些变量 *存活* 在哪里？换句话说，它们被存储在哪儿？而且，最重要的是，我们的程序如何在需要它们的时候找到它们？\n\n**回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组*规则*为：*作用域*。**\n\n但是，这些 *作用域* 规则是在哪里、如何被设置的？\n\n### 编译器理论\n\n尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是**其实它是一个编译型语言。它 *不是* 像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。**\n\n在传统的编译型语言处理中，一块儿源代码，你的程序，在它被执行 *之前* 通常将会经历三个步骤，大致被称为“编译”：\n\n1. **分词/词法分析：** 将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）。\n2. **解析：** 将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— **A**bstract **S**yntax **T**ree）。\n3. **代码生成：** 这个处理将抽象语法树转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。\n\n和大多数其他语言的编译器一样，JavaScript 引擎要比这区区三步复杂太多了。例如，在解析和代码生成的处理中，一定会存在优化执行效率的步骤，包括压缩冗余元素，等等。\n\n**JavaScript 引擎没有（像其他语言的编译器那样）大把的时间去优化，因为 JavaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中**。对 JavaScript 来说，在许多情况下，编译发生在代码被执行前的仅仅几微秒之内（或更少！）。\n\n为了简单起见，我们可以说，**任何 JavaScript 代码段在它执行之前（通常是 *刚好* 在它执行之前！）都必须被编译。**\n\n### 理解作用域\n\n让我们见一见处理程序 `var a = 2;` 时进行互动的演员吧，这样我们就能理解稍后将要听到的它们的对话：\n\n1. *引擎*：负责从始至终的编译和执行我们的 JavaScript 程序。\n2. *编译器*：*引擎* 的朋友之一；处理所有的解析和代码生成的重活儿（见前一节）。\n3. *作用域*：*引擎* 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。\n\n当你看到程序 `var a = 2;` 时，你很可能认为它是一个语句。但这不是我们的新朋友 *引擎* 所看到的。事实上，*引擎* 看到两个不同的语句，一个是 *编译器* 将在编译期间处理的，一个是 *引擎* 将在执行期间处理的。\n\n对于一个变量赋值，发生了两个不同的动作：第一，*编译器* 声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，*引擎* 在 *作用域* 中查询这个变量并给它赋值，如果找到的话。\n\n### 编译器术语\n\n当 *引擎* 执行 *编译器* 在第二步为它产生的代码时，它必须查询变量 `a` 来看它是否已经被声明过了，而且这个查询是咨询 *作用域* 的。但是 *引擎* 所实施的查询的类型会影响查询的结果。\n\n在我们这个例子中，*引擎* 将会对变量 `a` 实施一个“LHS”查询。另一种类型的查询称为“RHS”。\n\n对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地**查询某个变量的值**，而 LHS 查询是**试着找到变量容器本身**，以便它可以赋值。\n\n**注意：** 你可能会试图将函数声明 `function foo(a) {...` 概念化为一个普通的变量声明和赋值，比如 `var foo` 和 `foo = function(a){...`。这样做会诱使你认为函数声明涉及了一次 LHS 查询。\n\n然而，一个微妙但重要的不同是，**在这种情况下 *编译器* 在代码生成期间同时处理声明和值的定义，如此当 *引擎* 执行代码时，没有必要将一个函数值“赋予” `foo`。因此，将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的。**\n\n> 这里，我们需要将引擎这一概念细分，让引擎成为执行编译后代码的工具，而编译器负责编译代码，作用域负责利用规则管理变量。但如果从广义的去考虑，引擎可以包含刚刚所说的三部分。\n\n### 嵌套的作用域\n\n我们说过 *作用域* 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 *作用域* 需要考虑。\n\n就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，*引擎* 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）。\n\n### 错误\n\n为什么我们区别 LHS 和 RHS 那么重要？\n\n**因为在变量还没有被声明（在所有被查询的 *作用域* 中都没找到）的情况下，这两种类型的查询的行为不同**。\n\n如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 *引擎* 抛出一个 `ReferenceError`。必须要注意的是这个错误的类型是 `ReferenceError`。\n\n相比之下，如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 *作用域*）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 *作用域* 将会在 **全局作用域中** 创建一个同名的新变量，并把它交还给 *引擎*。\n\n现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。\n\n**`ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。**\n\n### 复习\n\n**作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找**。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。\n\n\n\n## 2.词法作用域\n\n**作用域的工作方式有两种占统治地位的模型**。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 **词法作用域**，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 **动态作用域**。\n\n### 词法分析时\n\n词法作用域这个名称来源于标准语言编译器的第一个传统步骤**词法分析**（也就是分词）\n\n**词法作用域是在词法分析时被定义的作用域**。换句话说，词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此**它在词法分析器处理你的代码时（基本上）是固定不变的**。\n\n[![img](assets/fig2-1547811838159.png)\n\n**气泡1** 包围着全局作用域，它里面只有一个标识符：`foo`。\n\n**气泡2** 包围着作用域 `foo`，它含有三个标识符：`a`，`bar` 和 `b`。\n\n**气泡3** 包围着作用域 `bar`，它里面只包含一个标识符：`c`。\n\n将这些作用域考虑为套在一起的气泡可能有助于思考。\n\n作用域气泡是根据作用域的块儿被写在何处定义的，一个嵌套在另一个内部，等等。在下一章中，我们将讨论作用域的不同单位，但是就现在来说，让我们认为**每一个函数创建了一个新的作用域气泡**。\n\n#### 查询\n\n**这些作用域气泡的结构和相对位置完全解释了 *引擎* 在查找一个标识符时，它需要查看的所有地方。**\n\n**一旦找到第一个匹配，作用域查询就停止了**。相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，**向外/向上不断查找**，直到第一个匹配才停止。\n\n**注意：** 全局变量也自动地是全局对象（在浏览器中是 `window`，等等）的属性，所以不直接通过全局变量的**词法名称**，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。如下：\n\n```js\nwindow.a\n```\n\n**这种技术给出了访问全局变量的方法，没有它全局变量将因为被遮蔽而不可访问**。然而，被遮蔽的非全局变量是无法**访问**的。\n\n> 如果变量是通过 let 或者 const 声明则无法在全局对象中访问到。\n\n不管函数是从 *哪里* 被调用的，也不论它是 *如何* 被调用的，它的词法作用域是由这个函数被声明的位置 **唯一** 定义的。\n\n词法作用域查询 *仅仅* 在处理头等标识符时实施，比如 `a`，`b`，和 `c`。如果你在一段代码中拥有一个 `foo.bar.baz` 的引用，词法作用域查询将在查找 `foo` 标识符时实施，但一旦定位这个变量，**对象属性访问规则**将会分别接管 `bar` 和 `baz` 属性的解析。\n\n### 欺骗词法作用域\n\nJavaScript 有两种这样的机制。在广大的社区中它们都等同地被认为是让人皱眉头的，在你代码中使用它们是一种差劲儿的做法。但是关于它们的常见的争论经常错过了最重要的一点：**欺骗词法作用域会导致更低下的性能。**\n\n- `eavl`\n  - JavaScript 中的 `eval(..)` 函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。换句话说，你可以用编程的方式在你编写好的代码内部生成代码，而且你可以运行这个生成的代码，就好像它在编写时就已经在那里了一样。\n- `with`\n  - `with` 语句接收一个对象，这个对象有0个或多个属性，并 **将这个对象视为好像它是一个完全隔离的词法作用域**，因此这个对象的属性被视为在这个“作用域”中词法定义的标识符。\n\n如果 `eval(..)` 函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而 `with` 语句实际上是从你传递给它的对象中凭空制造了一个 **全新的词法作用域**。\n\n#### 性能\n\n",[[1548241156172,["zhaoe@DESKTOP-124T69H",[[1,0,"---\nstyle: summer\n---\n"]],[123,123],[145,145]]],[1548241156793,["zhaoe@DESKTOP-124T69H",[[-1,11,"summer"],[1,17,"plain"]],[145,145],[144,144]]],[1548241157171,["zhaoe@DESKTOP-124T69H",[[-1,11,"plai"],[1,15,"ocea"]],[144,144],[144,144]]],[1548241157544,["zhaoe@DESKTOP-124T69H",[[-1,11,"o"],[-1,13,"e"],[1,16,"dy"]],[144,144],[144,144]]],[1548241157813,["zhaoe@DESKTOP-124T69H",[[-1,0,"---\nstyle: candy\n---\n"]],[144,144],[123,123]]]]]]}