# 24 | 理解声明合并

[TOC]

本节课我们来学习 TS 中的一个独特概念——**声明合并**

所谓**声明合并**就是指编译器会把程序多个地方具有相同名称的声明合并为一个声明。

这样做有一个好处，可以把程序中散落各处的重名声明合并在一起，比如你在程序中多个地方定义了同样名字的接口，那么在使用接口的时候就会对多出的定义同时具有感知能力，从而能够避免对接口成员的遗漏。

## 接口声明合并

首先我们来看一下**接口声明合并**，这也是 TS 中最常见的声明合并。

```ts
interface A {
  x: number;
}
interface A {
  y: number;
}

let a: A = {
  x: 1,
  y: 2
}
```

定义一个接口 `A` ，它有一个属性 `x` ，然后再定义一个同名的接口，它有一个属性 `y` ，这个时候两个接口就会合并为一个接口。接着，我们定义一个变量 `a` ，类型就是接口 `A` ，这个变量就需要具备两个接口中所有的成员。如果我们在编写的时候这是一个全局模块的话，那么这两个接口甚至可以不在一个文件中也可以发生接口的合并。下面我们就来关注一下接口的成员。

对于接口中非函数的成员，要求我们保证它的唯一性，如果不唯一，那么它们的类型必须相同，比如：

```ts
interface A {
  x: number;
  y: string; // 会造成后面定义相同接口名称中的相同成员名称 y 报错
}

interface A {
  y: number; // 报错
}
```

我们在第一个接口中再定义一个 `y` 属性，如果 `y` 的类型依然是 `number` ，那么是没有任何问题的，如果是 `string` 则不行会提示错误。

这是对于非函数成员，那么对于函数成员呢？每一个函数都会被声明为一个函数重载，比如：

```ts
interface A {
  x:number;
  foo (bar: number): number; // 3
}

interface A {
  y: number;
  foo (bar: string): string // 1
  foo (bar: number[]): number[]; // 2
}
```

我们在 `A` 接口中定义了一个函数 `foo`，在第二个 `A` 接口也定义一个 `foo` 函数，但其参数与返回值类型为 `string` ，然后再添加一个 `foo` 函数成员，其参数与返回值类型为 `number[]` ，这样就实现了一个函数重载。在接口中定义的函数就是这个函数重载的列表，那么在实现的时候就需要指定一个更为宽泛的类型：

```ts
let a: A = {
  x: 1,
  y: 1,
  foo(bar: any) {
    return bar
  }
}
```

 在对象 `a` 中添加 `foo` 的实现，将参数指定为 `any` 类型，返回值直接使用 `bar` ，由于类型推断，其也为 `any` 类型。这样就实现了一个函数重载。

在前面课程中，我们说过函数重载的时候需要注意函数声明的顺序，因为编译器会按顺序进行匹配，那么在接口合并的时候这些顺序是如何确定的呢？

有一个原则，在接口的内部就是按书写的顺序来确定，比如第二个 `A` 接口中，类型 `string` 会排在第一位，类型 `number[]` 会排在第二位。然后接口之间，会按照这个原则，也就是后面接口会排在前面，那么第一个 `A` 接口中的 `foo` 就会排在第三位。但也有一个例外，就是函数的参数是字符串字面量类型的话，那么这个声明就会提升到函数声明的最顶端。比如：

```ts
interface A {
  x:number;
  foo (bar: number): number; // 5
  foo (bar: 'a'): number; // 2
}

interface A {
  y: number;
  foo (bar: string): string // 3
  foo (bar: number[]): number[]; // 4
  foo (bar: 'b'): number; // 1
}
```

我们在第一个接口 `A` 中增加一个函数的定义它的参数为一个字面量类型，然后再在第二个 `A` 接口中增加一个函数定义，其参数也是一个字面量类型。那么现在函数声明顺序是怎样的呢？如上注释所示。

好了，这就是接口之间的声明合并。





## 命名空间的声明合并

### 命名空间之间的声明合并

其实在上节课我们已经接触到，回顾一下上节课的代码。

在两个文件中，我们分别定义了 `Shape` 命名空间，这个时候两个命名空间会发生合并，这里需要注意个问题，在命名空间中导出的成员是不可以重复定义的，比如：

在 `b.ts` 中：

```ts
/// <reference path="a.ts" />
namespace Shape {
    export function square(x: number) {
        return x * x
    }
}

console.log(Shape.circle(2))
console.log(Shape.square(2))
```

然后我们将 `square` 在 `a.ts` 中再重新导出：

```ts
namespace Shape {
    const pi = Math.PI
    export function circle(r: number) :number {
        return pi * r ** 2
    }
    export function square(x: number) { // 报错：函数实现重复。ts(2393)
      return x * x
  }
}
```

这里就会提示错误：**函数实现重复。ts(2393)** 。这个就和接口之间的声明合并有一个区别，接口之间是可以重复定义的，而在命名空间中不可以。



### 命名空间与函数的声明合并

```ts
function Lib() {}
namespace Lib {
  export let version = '1.0'
}
console.log(Lib.version) // => '1.0'  
```

我们先定义一个函数 `Lib` ，然后再定义一个同名的命名空间，在这个命名空间中我们导出一个变量 `version` ，这个就相当于给这个函数增加了一个属性，那么在 JS 中创建一个函数然后给它增加一些属性是很常见的一个模式，那么通过命名空间和函数的声明合并也可以实现这个模式。这里我们可以将其打印出来看一下，可以看到其值为 `'1.0'` ，说明 `version` 已经添加为 `Lib` 的属性。



### 命名空间与类的声明合并

```ts
class C {}
namespace C {
  export let state = 1
}
console.log(C.state) // => 1
```

声明一个类 `C` ，然后定义一个相同名称的命名空间，这里我们也导出一个变量 `state` ，这个就相当于给类添加了静态属性。



### 命名空间与枚举进行合并

```ts
enum Color {
  Red,
  Yello,
  Blue
}
namespace Color {
  export function mix() {}
}
console.log(Color) // 如下
{
  0: "Red",
  1: "Yello",
  2: "Blue",
  Blue: 2,
  Red: 0,
  Yello: 1,
  mix: f mix()
}
```

定义一个枚举 `Color` ，然后我们定义一个相同名称的命名空间，在这个命名空间中我们可以导出一个函数，这样就相当于给这个枚举类型增加了一个方法。接着，我们打印一下 `Color` ，看一下 `Color` 在执行环境中是什么样子的，可以看到枚举实际是一个对象，其被添加了一个 `mix` 方法。

这里需要注意一个问题，就是命名空间在与函数进行声明合并或者与类进行声明合并的时候，一定要将命名空间的声明放在类或者函数的后面。而枚举和命名空间的关系是没有要求的，那为什么会有这个问题呢？（课后思考题）



## 为什么会有声明合并

**在我们的程序中，如果有多个重名的声明，其实并不是一个好的模式，最好还是把它们封装在一个模块之内，TS 具有这种特性显然是照顾那些旧的开发模式，这使得在我们的工程中如果引入了 TS，任然能够与老的代码共存并且还能够发现其中的一些设计缺陷。**













