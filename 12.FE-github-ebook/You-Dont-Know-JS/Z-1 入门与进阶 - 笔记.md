# 入门与进阶 - 笔记

[TOC]

## 1.进入编程

### 程序

**一个程序，经常被称为 *源代码* 或者只是 *代码*，是一组告诉计算机要执行什么任务的特殊指令**。代码通常保存在文本文件中，虽然你也可以使用 JavaScript 在一个浏览器的开发者控制台中直接键入代码

**程序只是许多语句的集合，它们一起描述为了执行你的程序的意图所要采取的所有*步骤*。**

### 计算机语言/语法

**合法的格式与指令的组合规则被称为一种 *计算机语言***，有时被称作它的 *语法*，这和英语教你如何拼写单词，和如何使用单词与标点创建合法的句子差不多是相同的。

### 语句

在一门计算机语言中，一组单词，数字，和执行一种具体任务的操作符构成了一个 *语句*。在JavaScript中，一个语句可能看起来像下面这样：

```js
a = b * 2;
```

在JavaScript中大多数语句都以末尾的分号（`;`）结束。

语句`a = b * 2;`告诉计算机，大致上，去取得当前存储在变量`b`中的值，将这个值乘以`2`，然后将结果存回到另一个我们称为`a`变量里面。

### 变量

字符`a`和`b`被称为 *变量*（参见“变量”），它们就像简单的盒子，你可以把任何东西存储在其中。在程序中，变量持有将被程序使用的值（比如数字`42`）。可以认为它们就是**值本身的标志占位符**。

不管哪种方式，你将会注意到`amount`持有一个在程序运行过程中不断变化的值，这展示了变量的主要目地：管理程序 *状态*。

### 字面量/字面值

相比之下，`2`本身只是一个值，称为一个 ***字面值*，因为它没有被存入一个变量，是独立的。**

### 操作符

字符`=`和`*`是 *操作符*（见“操作符”） —— **它们使用值和变量实施动作**，比如赋值和数学乘法。

### 表达式

**语句是由一个或多个 *表达式* 组成的。一个表达式是一个引用，指向变量或值，或者一组用操作符组合的变量和值。**

有如下表达式：

- `2`是一个 ***字面量表达式***
- `b`是一个 ***变量表达式***，它意味着取出它的当前值
- `b * 2`是一个 ***算数表达式***，它意味着执行乘法
- `a = b * 2`是一个 ***赋值表达式***，它意味着将表达式`b * 2`的结果赋值给变量`a`（稍后有更多关于赋值的内容）

每一种表达式，都可以称为表达式语句，虽然像字面量表达式、变量表达式、算数表达式这样不是很常见也没有什么用，因为一般来说它不会对程序的运行有任何影响。

一种更常见的表达式语句是 *调用表达式* 语句（见“函数”），因为整个语句本身是一个函数调用表达式：

```
alert( a );
```

### 执行一个程序 - 解释与编译

这些程序语句的集合如何告诉计算机要做什么？这个程序需要被 *执行*，也称为 *运行这个程序*。

在开发者们阅读与编写时，像`a = b * 2`这样的语句很有帮助，但是它实际上不是计算机可以直接理解的形式。所以一个计算机上的特殊工具（不是一个 *解释器* 就是一个 *编译器*）被用于将你编写的代码翻译为计算机可以理解的命令。

对于某些计算机语言，这种命令的翻译经常是在每次程序运行时从上向下，一行接一行完成的，这通常称为代码的 *解释*。

> **解释**像是有一个同声传译的翻译在帮忙，一直在用计算机能够理解的机器码去**解释**程序员来编写的程序语言。

对于另一些语言，这种翻译是提前完成的，称为代码的 *编译*，所以当程序稍后 *运行* 时，实际上运行的东西已经是编译好，随时可以运行的计算机指令了。

> **编译**则像是一个书籍翻译，将一本程序员所编写好的代码书**编译**为计算机所能看懂的机器码。

JavaScript 通常被断言为是 *解释型* 的，因为你的 JavaScript 源代码在它每次运行时都被处理。但这并不是完全准确的。JavaScript 引擎实际上在即时地 *编译* 程序然后立即运行编译好的代码。

### 输出

在使用`console.log(..)`的输出文本的代码中，让我们简单地看看这一行代码在做什么。

- 首先，`log( b )`部分被称为一个函数调用（见“函数”）。这里发生的事情是，我们将变量`b`交给这个函数，它向变量`b`要来它的值，并在控制台中打印。

- 第二，`console.`部分是一个**对象引用**，这个对象就是**找到`log(..)`函数的地方**。我们会在第二章中详细讲解对象和它们的属性。

另一种创建你可以看到的输出的方式是运行`alert(..)`语句。

### 输入

虽然我们在讨论输出，你也许还想知道 *输入*（例如，从用户那里获得信息）。

对于 HTML 网页来说，输入发生的最常见的方式是向用户显示一个他们可以键入的 form 元素，然后使用 JS 将这些值读入你程序的变量中。

但是为了单纯的学习和展示的目的 —— 也就是你在这本书中将通篇看到的 —— 有一个获取输入的更简单的方法。使用`prompt(..)`函数：

```js
age = prompt( "Please tell me your age:" );

console.log( age );
```

正如你可能已经猜到的，你传递给`prompt(..)`的消息 —— 在这个例子中，`"Please tell me your age:"` —— 被打印在弹出框中。ai操作符

### 操作符

这里是一些在 JavaScript 中最常见的**操作符**：

- 赋值：比如`a = 2`中的`=`。

- 数学：`+`（加法），`-`（减法），`*`（乘法），和`/`（除法）、`%`(求余)，比如`a * 3`。

- 复合赋值：`+=`，`-=`，`*=`，和`/=`都是复合操作符，它们组合了数学操作和赋值，比如`a += 2`（与`a = a + 2`相同）。

- 递增/递减：`++`（递增），`--`（递减），比如`a++`（和`a = a + 1`很相似）。

- **对象属性访问**：比如`console.log()`的`.`。

  对象是一种值，它可以在被称为属性的，被具体命名的位置上持有其他的值。`obj.a`意味着一个称为`obj`的对象值有一个名为`a`的属性。属性可以用`obj["a"]`这种替代的方式访问。参见第二章。

- 等价性：`==`（宽松等价），`===`（严格等价），`!=`（宽松不等价），`!==`（严格不等价），比如`a == b`。

  参见“值与类型”和第二章。

- 比较：`<`（小于），`>`（大于），`<=`（小于或宽松等价），`>=`（大于或宽松等价），比如`a <= b`。

  参见“值与类型”和第二章。

- 逻辑：`&&`（与），`||`（或），比如`a || b`它选择`a`*或*`b`中的一个。

  这些操作符用于表达复合的条件（见“条件”），比如如果`a`*或者*`b`成立。

### 值与类型

当你在程序中表达一个值时，你根据你打算对这些值做什么来选择不同的表达形式。

**在编程术语中值的这些不同的表达形式称为 *类型***。JavaScript 中对这些所谓的 *基本类型* 值都有内建的类型：

- 当你需要做数学计算时，你需要一个`number`。
- 当你需要在屏幕上打印一个值时，你需要一个`string`（一个或多个字符，单词，句子）。
- 当你需要在你的程序中做决定时，你需要一个`boolean`（`true`或`false`）。

在源代码中直接包含的值称为 *字面量*。`string`字面量被双引号`"..."`或单引号（`'...'`）包围 —— 唯一的区别是风格上的偏好。`number`和`boolean`字面量用它们本身来表示（即，`42`，`true`，等等）。

在`string`/`number`/`boolean`值的类型以外，编程语言通常会提供 *数组*，*对象*，*函数* 等更多的类型。

### 类型间转换

如果你有一个`number`但需要将它打印在屏幕上，那么你就需要将这个值转换为一个`string`，在JavaScript中这种转换称为“强制转换”。类似地，如果某些人在一个电商网页的form中输入一系列数字，那么它是一个`string`，但是如果你需要使用这个值去做数学运算，那么你就需要将它 *强制转换* 为一个`number`。

当比较字符串`"99.99"`和数字`99.99`时，大多数人同意它们是等价的。但是他们不完全相同，不是吗？它们是**相同的值的两种不同表现形式**，两个不同的 *类型*。你可以说它们是“宽松地等价”的，不是吗？

为了在这些常见情况下帮助你，JavaScript有时会启动 *隐含的* 强制转换来把值转换为匹配的类型。

所以如果你使用`==`宽松等价操作符来进行`"99.99" == 99.99`比较，JavaScript会将左手边的`"99.99"`转换为它的`number`等价物`99.99`。所以比较就变成了`99.99 == 99.99`，这当然是成立的。

虽然隐含强制转换是为了帮助你而设计，但是它也可能把你搞糊涂，如果你没有花时间去学习控制它行为的规则。大多数开发者从没有这么做，所以常见的感觉是隐含的强制转换是令人困惑的，并且会产生意外的bug危害程序，因此应当避免使用。有时它甚至被称为这种语言中的设计缺陷。

然而，隐含强制转换是一种 *可以被学习* 的机制，而且是一种 *应当* 被所有想要认真对待JavaScript编程的人学习的机制。**一旦你学习了这些规则，它不仅是消除了困惑，而且它实际上是你的程序变得更好！**这种努力是值得的。

### 代码注释

手机店店员可能会写下一些笔记，记下新出的手机的特性或者他们公司推出的新套餐。这些笔记仅仅是给店员使用的 —— 他们不是给顾客读的。不管怎样，通过记录下为什么和如何告诉顾客他应当说的东西，这些笔记帮助店员更好的工作。

关于编写代码你要学的最重要的课程之一，就是它不仅仅是写给计算机的。**代码的每一个字节都和写给编译器一样，也是写给开发者的。**

**你的计算机只关心机器码**，一系列源自 *编译* 的0和1。你几乎可以写出无限多种可以产生相同0和1序列的代码。所以你对如何编写程序作出的决定很重要 —— 不仅是对你，也对你的团队中的其他成员，甚至是你未来的自己。

你不仅应当努力去编写可以正确工作的程序，而且应当努力编写解释起来有道理的程序。你可以通过给变量（见“变量”）和函数（见“函数”）起一个好名字在这条路上走很远。

关于什么是良好注释的代码有许多意见；我们不能真正地定义绝对统一的规则。但是一些意见和指导是十分有用的：

- 没有注释的代码是次优的。
- 过多的注释（比如，每行都有注释）可能是代码编写的很烂的标志。
- **注释应当解释 *为什么*，而不是 *是什么*。它们可以选择性地解释 *如何做*，如果代码特别令人困惑的话。**

### 块儿

在你买你的新手机时，手机店店员必须走过一系列步骤才能完成结算。

相似地，在代码中我们经常需要**将一系列语句一起分为一组，这就是我们常说的 *块儿***。在JavaScript中，一个块儿被定义为包围在一个大括号`{ .. }`中的一个或多个语句。考虑如下代码：

```
var amount = 99.99;

// 一个普通的块儿
{
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

这种独立的`{ .. }`块儿是合法的，但是在JS程序中并不常见。一般来说，**块儿是添附在一些其他的控制语句后面的**，比如一个`if`语句（见“条件”）或者一个循环（见“循环”）。例如：

```js
var amount = 99.99;

// 数值够大吗？
if (amount > 10) {			// <-- 添附在`if`上的块儿
	amount = amount * 2;
	console.log( amount );	// 199.98
}
```

### 条件

“你想来一个额外的屏幕贴膜吗？只要$9.99。” 热心的手机店店员请你做个决定。而你也许需要首先咨询一下钱包或银行帐号的 *状态* 才能回答这个问题。但很明显，这只是一个简单的“是与否”的问题。

> *状态*是人或事物表现出来的形态。是指现实（或虚拟）事物处于生成、生存、发展、消亡时期或各转化临界点时的形态或事物态势。
>
> 以上是百度给出的解释。
>
> 我的理解是，状态表示的是事物在某个时间点或者时间段所表现的信息的集合。从宏观的角度看，一个人的状态变化可能是缓慢的，一会儿开心一会儿悲伤，昨天身体还很好，今天就感冒了，刚才是坐着的，等下又站起来的了；从微观的角度来看，人的变化也可以是快速的，身体的细胞无时无刻不在变化。
>
> 一个程序的状态，是指其内部变量的值，因为程序的状态是由变量来表现的，如果一个程序因为执行了某个表达式或者语句块从而改变了其内部的变量，那么我们可以认为其状态发生了改变。

最常见的一个就是`if`语句。实质上，你在说，“*如果* 这个条件成立，做后面的……”。例如：

```js
var bank_balance = 302.13;
var amount = 99.99;

if (amount < bank_balance) {
	console.log( "I want to buy this phone!" );
}
```

`if`语句在括号`( )`之间需要一个表达式，它不是被视作`true`就是被视作`false`。在这个程序中，我们提供了表达式`amount < bank_balance`，它确实会根据变量`bank_balance`中的值被求值为`true`或`false`。

### 循环

在繁忙的时候，有一张排队单，上面记载着需要和手机店店员谈话的顾客。虽然排队单上还有许多人，但是她只需要持续服务下一位顾客就好了。

重复一组动作直到特定的条件失败 —— 换句话说，**仅在条件成立时重复 —— 就是程序循环的工作；循环可以有不同的形式，但是它们都符合这种基本行为。**

一个循环包含测试条件和一个块儿（通常是`{ .. }`）。每次循环块儿执行，都称为一次 *迭代*。

例如，`while`循环和`do..while`循环形式就说明了这种概念 —— 重复一块儿语句直到一个条件不再求值得`true`：

```js
while (numOfCustomers > 0) {
	console.log( "How may I help you?" );

	// 服务顾客……

	numOfCustomers = numOfCustomers - 1;
}

// 与

do {
	console.log( "How may I help you?" );

	// 服务顾客……

	numOfCustomers = numOfCustomers - 1;
} while (numOfCustomers > 0);
```

`for`循环有三个子句：初始化子句（`var i=0`），条件测试子句（`i <= 9`），和更新子句（`i = i + 1`）。所以如果你想要使用循环迭代来计数，`for`是一个更紧凑而且更易理解和编写的形式。

还有一些意在迭代特定的值的特殊循环形式，比如迭代一个对象的属性（见第二章），**它隐含的测试条件是所有的属性是否都被处理过了**。无论循环是何种形式，**“循环直到条件失败”**的概念是它们共有的。

### 函数

手机店的店员可能不会拿着一个计算器到处走，用它来搞清税费和最终的购物款。这是一个她需要定义一次然后一遍又一遍地重用的任务。很有可能的是，公司有一个带有内建这些“功能”的收银机（电脑，平板电脑，等等）。

相似地，几乎可以肯定你的程序想要将代码的任务分割成可以重用的片段，而不是频繁地多次重复自己。这么做的方法是定义一个`function`。

**一个函数一般来说是一段被命名的代码**，它可以使用名称来被“调用”，而每次调用它内部的代码就会运行。

函数可以选择性地接收参数值（也就是参数）—— 你传入的值。而且它们还可以选择性地返回一个值。

函数经常被用于你打算多次调用的代码，但它们对于仅**将有关联的代码组织在一个命名的集合中也很有用，即便你只打算调用它们一次**。

虽然`calculateFinalPurchaseAmount(..)`只被调用了一次，但是将它的行为组织进一个分离的带名称的函数，让使用它逻辑的代码（`amount = calculateFinal...`语句）更干净。如果函数中拥有更多的语句，这种好处将会更加明显。

> 使用函数的方式封装代码的好处在于，除了可以重复使用以外，也将代码的逻辑变得更清晰，至少对于未来的你和阅读你代码的人而言，更清楚这些一块一块的代码的作用。

### 作用域

如果你向手机店的店员询问一款她们店里没有的手机，那么她就不能卖给你你想要的。她只能访问她们店库房里的手机。你不得不到另外一家店里去看看能不能找到你想要的手机。

编程对这种概念有一个术语：*作用域*（技术上讲称为 *词法作用域*）。**在JavaScript中，每个函数都有自己的作用域。作用域基本上就是变量的集合，也是如何使用名称访问这些变量的规则**。只有在这个函数内部的代码才能访问这个函数 *作用域内* 的变量。

在同一个作用域内变量名必须是唯一的 —— 不能有两个不同的变量`a`并排出现。但是相同的变量名`a`可以出现在不同的作用域中。

另外，一个作用域可以嵌套在另一个作用域中，就像生日Party上的小丑在一个气球的里面吹另一个气球一样。如果一个作用域嵌套在另一个中，那么在内部作用域中的代码就可以访问这两个作用域中的变量。

词法作用域规则说，在一个作用域中的代码既可以访问这个作用域中的变量，又可以访问任何在它外面的作用域的变量。

### 复习

学习编程不一定是个复杂而且巨大的过程。你只需要在脑中装进几个基本的概念。

它们就像构建块儿。要建一座高塔，你就要从堆砌构建块儿开始。编程也一样。这里是一些编程中必不可少的构建块儿：

- 你需要 *操作符* 来在值上实施动作。
- 你需要值和 *类型* 来试试不同种类的动作，比如在`number`上做数学，或者使用`string`输出。
- 你需要 *变量* 在你程序执行的过程中存储数据（也就是 *状态*）。
- 你需要 *条件*，比如`if`语句来做决定。
- 你需要 *循环* 来重复任务，直到一个条件不再成立。
- 你需要 *函数* 来将你的代码组织为有逻辑的和可复用的块儿。

代码注释是一种编写更好可读性代码的有效方法，它使你的代码更易理解，维护，而且如果稍后出现问题的话更易修改。

最后，不要忽视练习的力量。学习写代码的最好方法就是写代码。

现在，我很高兴看到你在学习编码的道路上走得很好！保持下去。不要忘了看看其他编程初学者的资源（书，博客，在线教学，等等）。这一章和这本书是一个很好的开始，但它们只是一个简要的介绍。

下一章将会复习许多本章中的概念，但是是从更加专门于 JavaScript 的视角，这将突出将在本系列的剩余部分将要深度剖析的大多数主要话题。

---

## 2. 进入 JavaScript

### 值与类型

JavaScript 拥有带类型的值，没有带类型的变量。

下面是可用的**内建类型**：

- `string`
- `number`
- `boolean`
- `null` 和 `undefined`
- `object`
- `symbol` （ES6新增类型）

> 内置类型又可以分为**原始类型**与**对象类型**。除了`object`以外都是**原始类型**。

注意在这个代码段中变量`a`是如何持有每种不同类型的值的，而且尽管表面上看起来很像，但是`typeof a`并不是在询问“`a`的类型”，**而是“当前`a`中的值的类型”**。**在JavaScript中只有值拥有类型；变量只是这些值的简单容器。**

#### 对象

`object`类型指的是一种**复合值**，你可以在它上面设定**属性**（**带名称的位置**），每个属性持有各自的任意类型的值。它也许是JavaScript中最有用的类型之一。

- 属性既可以使用 *点号标记法*（例如，`obj.a`） 访问，也可以使用 *方括号标记法*（例如，`obj["a"]`） 访问。点号标记法更短而且一般来说更易于阅读，因此在可能的情况下它都是首选。
- 在 JavaScript 程序中有另外两种你将会经常打交道的值类型：*数组* 和 *函数*。但与其说它们是内建类型，**这些类型应当被认为更像是子类型 —— `object`类型的特化版本。**

#### 数组

一个数组是一个`object`，它不使用特殊的带名称的属性/键持有（任意类型的）值，而是使用数字索引的位置。

- 因为**数组是一种特殊的对象（正如`typeof`所暗示的）**，所以它们可以拥有属性，**包括一个可以自动被更新的`length`属性。**

> 理论上你可以使用你自己的命名属性将一个数组用作一个普通对象，或者你可以使用一个`object`但是给它类似于数组的数字属性（`0`，`1`，等等）。然而，这么做一般被认为是分别误用了这两种类型。
>
> 最好且最自然的方法是为数字定位的值使用数组，而为命名属性使用`object`。

#### 函数

同样地，函数也是`object`的子类型 —— `typeof`返回`"function"`，这**暗示着`"function"`是一种主要类型** —— 因此也可以拥有属性，但是你一般仅会在有限情况下才使用函数对象属性（比如`foo.bar`）。

### 内建类型的方法

**内建类型**和**子类型**拥有十分强大和有用的行为，它们作为属性和方法暴露出来。

使调用`a.toUpperCase()`成为可能的原因，要比这个值上存在这个方法的说法复杂一些。

简而言之，有一个`String`（`S`大写）对象包装器形式，通常被称为**“原生类型”**，**与`string`基本类型配成一对儿**；正是这个对象包装器的原型上定义了`toUpperCase()`方法。

当你通过引用一个属性或方法（例如，前一个代码段中的`a.toUpperCase()`）将一个像`"hello world"`这样的基本类型值当做一个`object`来使用时，JS自动地将这个值“封箱”为它对应的对象包装器（这个操作是隐藏在幕后的）。

> **一个`string`值可以被包装为一个`String`对象，一个`number`可以被包装为一个`Number`对象，而一个`boolean`可以被包装为一个`Boolean`对象。在大多数情况下，你不必担心或者直接使用这些值的对象包装器形式 —— 在所有实际情况中首选基本类型值形式，而JavaScript会帮你搞定剩下的一切。**

### 值的比较

在你的 JS 程序中你将需要进行两种主要的值的比较：*等价* 和 *不等价*。任何比较的结果都是严格的`boolean`值（`true`或`false`），无论被比较的值的类型是什么。

#### 强制转换

在 JavaScript 中强制转换有两种形式：***明确的*** 和 ***隐含的***。明确的强制转换比较简单，因为你可以在代码中明显地看到一个类型转换到另一个类型将会发生，而隐含的强制转换更像是另外一些操作的不明显的副作用引发的类型转换。

> 比如 Number("123") 为明确的强制转换，而 1 * "42" 则会隐含的类型转换

#### Truthy 与 Falsy

值的“truthy”和“falsy”性质：当一个非`boolean`值被强制转换为一个`boolean`时，它是变成`true`还是`false`。

在 JavaScript 中“falsy”的明确列表如下：

- `""` （空字符串）
- `0`, `-0`, `NaN` （非法的`number`）
- `null`, `undefined`
- `false`

任何不在这个“falsy”列表中的值都是“truthy”。这是其中的一些例子：

- `"hello"`
- `42`
- `true`
- `[ ]`, `[ 1, "2", 3 ]` （数组）
- `{ }`, `{ a: 42 }` （对象）
- `function foo() { .. }` （函数）

#### 等价性

有四种等价性操作符：`==`，`===`，`!=`，和`!==`。`!`形式当然是与它们相对应操作符平行的“不等”版本；*不等（non-equality）* 不应当与 *不等价性（inequality）* 相混淆。

`==`和`===`之间的不同通常被描述为，`==`检查值的等价性而`===`检查值和类型两者的等价性。然而，这是不准确的。描述它们的合理方式是，**`==`在允许强制转换的条件下检查值的等价性，而`===`是在不允许强制转换的条件下检查值的等价性；因此`===`常被称为“严格等价”。**

**许多开发者感觉`===`更可靠，所以他们提倡一直使用这种形式而远离`==`。我认为这种观点是非常短视的。我相信`==`是一种可以改进程序的强大工具，*如果你花时间去学习它的工作方式*。**

> 比如你从一个 input 中获取到一个数字字符串，然后需要跟一个数字比较，如果使用严格等价`===`，则需要先进行转换，而如果使用非严格等价`==`，则不需要转换。从而简化了你的代码并且改善了可读性。

### 不等价性

`<`，`>`，`<=`，和`>=`操作符用于**不等价性比较**，在语言规范中被称为“关系比较”。一般来说它们将与`number`这样的可比较有序值一起使用。`3 < 4`是很容易理解的。

但是JavaScript`string`值也可进行不等价性比较，它使用典型的字母顺序规则（`"bar" < "foo"`）。

如果两个值之一不是`string`，就像`'43' < 45`，那么两个值就将被强制转换成`number`，并进行一般的数字比较。

在可能不同类型的值之间进行比较时，你可能遇到的最大的坑 —— 记住，没有“严格不等价”可用 —— 是其中一个值不能转换为合法的数字，例如：

```js
var a = 42;
var b = "foo";

a < b;		// false
a > b;		// false
a == b;		// false
```

这三个比较怎么可能都是`false`？因为在`<`和`>`的比较中，值`b`被强制转换为了“非法的数字值”，而且**语言规范说`NaN`既不大于其他值，也不小于其他值。**

### 变量

在 JavaScript 中，变量名（包括函数名）必须是合法的 ***标识符（identifiers）***。当你考虑非传统意义上的字符时，比如Unicode，标识符中合法字符的严格和完整的规则就有点儿复杂。如果你仅考虑典型的ASCII字母数字的字符，那么这个规则还是很简单的。

一个标识符必须以`a`-`z`，`A`-`Z`，`$`，或`_`开头。它可以包含任意这些字符外加数字`0`-`9`。

一般来说，变量标识符的规则也通用适用于属性名称。然而，有一些不能用作变量名，但是可以用作属性名的单词。这些单词被称为“保留字（reserved words）”，包括JS关键字（`for`，`in`，`if`，等等）和`null`，`true`和`false`。

### 函数作用域

你使用`var`关键字声明的变量将属于**当前的函数作用域**，如果声明位于任何函数外部的顶层，它就属于**全局作用域**。

#### 提升

**无论`var`出现在一个作用域内部的何处，这个声明都被认为是属于整个作用域，而且在作用域的所有位置都是可以访问的，这种行为称为 *提升***

比喻一个`var`声明在概念上 *被移动* 到了包含它的作用域的顶端。技术上讲，这个过程通过代码的编译方式进行解释更准确，但是我们先暂且跳过那些细节。

> 警告： 在一个作用域中依靠变量提升来在`var`声明出现之前使用一个变量是不常见的，也不是个好主意；它可能相当使人困惑。而**使用被提升的函数声明要常见得多，也更为人所接受**

> 学习了关于「作用域」的一章，我想在这里对提升做一个补充。
>
> 之所以会存在提升是由于 JS 是编译性语言，在引擎执行之前的几毫秒会有一个编译过程，因此会提前编译一遍整个代码或者部分代码，在这个过程中，一旦发现有声明变量函数就会将变量或者函数交给作用域来管理，当引擎对编译后的代码执行时，因为作用域中已经存在变量或者函数，所以对其**访问**或者调用就不会报错。只不过需要注意的是，编译器对于变量只会将其标识符存放在内存中由作用域管理而不会将其值也存放在内存中，而只有当引擎在执行的过程中，遇到赋值语句时才会将其值存放到内存，而函数不同，函数是 *编译器* 在代码生成期间同时处理声明和值的定义，也因此引擎在执行函数声明代码时并不会将一个函数值赋值给变量。
>
> 注意：LHS 与 RHS 查询的区别。

#### 嵌套的作用域

当你声明了一个变量时，它就在这个作用域内的任何地方都是可用的，包括任何下层/内部作用域。

如果你试着为一个还没有被声明的变量赋值，那么根据“strict模式”的状态，你会要么得到一个在顶层全局作用域中创建的变量（不好！），要么得到一个错误。

除了在函数级别为变量创建声明，ES6允许你使用`let`关键字声明属于个别块儿（一个`{ .. }`）的变量。对于以更加细粒度的方式管理你的变量作用域来说，块儿作用域是非常有用的，它将使你的代码随着时间的推移更加易于维护。

### 条件

除了我们在第一章中简要介绍过的`if`语句，JavaScript 还提供了几种其他值得我们一看的条件机制：

- `if...else` 或者 `if...else if...else`

- `switch(){case: ...break; default:}`

  - **如果你想仅让一个`case`中的语句运行，`break`是很重要的。如果你在一个`case`中省略了`break`，并且这个`case`成立或运行，那么程序的执行将会不管下一个`case`语句是否成立而继续执行它。这种所谓的“掉落”有时是有用/期望的**：

    ```js
    switch (a) {
    	case 2:
    	case 10:
    		// 一些很酷的事情
    		break;
    	case 42:
    		// 另一些事情
    		break;
    	default:
    		// 备用方案
    }
    ```

    - 这里，如果`a`是`2`或`10`，它就会执行“一些很酷的事情”的代码语句。

- 在JavaScript中的另一种条件形式是“条件操作符”，经常被称为“三元操作符”。

#### Strict 模式

ES5在语言中加入了一个“strict模式”，它收紧了一些特定行为的规则。一般来说，这些限制被视为使代码符合一组**更安全和更合理的指导方针**。另外，坚持strict模式一般会使你的代码**对引擎有更强的可优化性**。strict模式对代码有很大的好处，你应当在你所有的程序中使用它。

**根据你摆放strict模式注解的位置，你可以为一个单独的函数，或者是整个一个文件切换到strict模式：**

```js
function foo() {
	"use strict";

	// 这部分代码是strict模式的

	function bar() {
		// 这部分代码是strict模式的
	}
}

// 这部分代码不是strict模式的
```

它**不允许因为省略了`var`而进行隐含的自动全局变量声明**：

```js
function foo() {
	"use strict";	// 打开strict模式
	a = 1;			// 缺少`var`，ReferenceError
}

foo();
```

如果你在代码中打开strict模式，并且得到错误，或者代码开始变得有bug，这可能会诱使你避免使用strict模式。但是纵容这种直觉不是一个好主意。如果strict模式在你的程序中导致了问题，那么这标志着在你的代码中几乎可以肯定有应该修改的东西。

strict 模式不仅**将你的代码保持在更安全的道路上**，也不仅将**使你的代码可优化性更强**，它还**代表着这种语言未来的方向**。对于你来说，现在就开始习惯于strict模式要比一直回避它容易得多 —— 以后再进行这种转变只会更难！

#### 函数作为值

至此，我们已经将函数作为 JavaScript 中主要的 *作用域* 机制讨论过了。你可以回想一下典型的`function`声明语法是这样的：

```js
function foo() {
	// ..
}
```

**虽然从这种语法中看起来不明显，`foo`基本上是一个位于外围作用域的变量，它给了被声明的`function`一个引用。也就是说，`function`本身是一个值，就像`42`或`[1,2,3]`一样。**

这可能听起来像是一个奇怪的概念，所以花点儿时间仔细考虑一下。你不仅可以向一个`function`传递一个值（参数值），**而且 *一个函数本身可以是一个值*，它能够赋值给变量，传递给其他函数，或者从其它函数中返回。**

因此，一个函数值应当被认为是一个表达式，与任何其他的值或表达式很相似。

考虑如下代码：

```js
var foo = function() {
	// ..
};

var x = function bar(){
	// ..
};
```

第一个被赋值给变量`foo`的函数表达式称为 ***匿名* 函数表达式**，因为它没有“名称”。

第二个函数表达式是 *命名的*（`bar`），它还被赋值给变量`x`作为它的引用。*命名函数表达式* 一般来说更理想，虽然 *匿名函数表达式* 仍然极其常见。

#### 立即被调用的函数表达式（IIFE）

在前一个代码段中，哪一个函数表达式都没有被执行 —— 除非我们使用了`foo()`或`x()`。

有另一种执行函数表达式的方法，它通常被称为一个 *立即被调用的函数表达式* （IIFE）：

```js
(function IIFE(){
	console.log( "Hello!" );
})();
// "Hello!"
```

围绕在函数表达式`(function IIFE(){ .. })`外部的`( .. )`只是一个**微妙的JS文法**，我们**需要它来防止函数表达式被看作一个普通的函数声明**。

在表达式末尾的最后的`()` —— `})();`**这一行 —— 才是实际立即执行它前面的函数表达式的东西**。

因为IIFE只是一个函数，而函数可以创建变量 *作用域*，以这样的风格使用一个 IIFE 经常被用于定义变量，而这些变量将不会影响围绕在 IIFE 外面的代码。

> 但如果使用闭包或者，将变量传递给外面的变量则有可能会影响周围的代码。

IIFE还可以有返回值：

```js
var x = (function IIFE(){
	return 42;
})();

x;	// 42
```

#### 闭包

**你可以认为闭包是这样一种方法：即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域**。

> 闭包可以认为是，函数内部拥有对其外部变量的访问空间。可以会有如下这样的描述：
>
> - 你会认为像`username`和`password`这样的内部变量将会消失。但是在这里它们不会，因为在`login()`函数里有一个闭包使它们继续存活。
> - 内部的`doLogin()`函数在`username`和`password`上拥有闭包，这意味着即便`User()`函数已经完成了运行，它依然持有对它们的访问权。

#### 模块

**在 JavaScript 中闭包最常见的用法就是模块模式**。模块让你定义对外面世界不可见的私有实现细节（变量，函数），和对外面可访问的公有API。

> 我们可以认为在 JavaScript 中实现模块化开发是基于闭包这种方法。

#### this` 标识符

虽然`this`可能经常看起来是与“面向对象模式”有关的，但在JS中`this`是一个不同的概念。

如果一个函数在它内部拥有一个`this`引用，那么这个`this`引用通常指向一个`object`。但是指向哪一个`object`要看这个函数是如何被调用的。

重要的是要理解`this` *不是* 指函数本身，这是最常见的误解。

```js
function foo() {
	console.log( this.bar );
}

var bar = "global";

var obj1 = {
	bar: "obj1",
	foo: foo
};

var obj2 = {
	bar: "obj2"
};

// --------

foo();				// "global"
obj1.foo();			// "obj1"
foo.call( obj2 );	// "obj2"
new foo();			// undefined
```

关于`this`如何被设置有四个规则，它们被展示在这个代码段的最后四行中：

1. `foo()`最终在非strict模式中将`this`设置为全局对象 —— 在strict模式中，`this`将会是`undefined`而且你会在访问`bar`属性时得到一个错误 —— 所以`this.bar`的值是`global`。
2. `obj1.foo()`将`this`**设置为**对象`obj1`。
3. `foo.call(obj2)`将`this`**设置为**对象`obj2`。
4. `new foo()`将`this`设置为一个新的空对象。

### 原型

当你引用一个对象上的属性时，如果这个属性不存在，JavaScript 将会自动地使用这个对象的内部原型引用来寻找另外一个对象，在它上面查询你想要的属性。你可以认为它几乎是在属性缺失时的**备用对象**。

**从一个对象到它备用对象的内部原型引用链接发生在这个对象被创建的时候**。说明它的最简单的方法是使用称为`Object.create(..)`的内建工具。

**这种链接看起来是语言的一种奇怪的特性。这种特性最常被使用的方式 —— 我会争辩说这是一种滥用 —— 是用来模拟/模仿“类”机制的“继承”。**

### 旧的与新的

我们已经介绍过的 JS 特性，和将在这个系列的其他部分中讲解的相当一部分特性都是新近增加的，不一定在老版本的浏览器中可用。事实上，语言规范中的一些最新特性甚至在任何稳定的浏览中都没有被实现。

那么，你拿这些新东西怎么办？你只能等上几年或者十几年直到老版本浏览器归于尘土？

这确实是许多人认为的情况，但是它不是JS健康的进步方式。

有两种主要的技术可以将新的JavaScript特性“带到”老版本的浏览器中：**填补**和**转译**。

#### 填补

“填补（Polyfilling）”是一个人为发明的词（由Remy Sharp创造）（<https://remysharp.com/2010/10/08/what-is-a-polyfill> ）。它是指拿来一个新特性的定义并制造一段行为等价的代码，但是这段代码可以运行在老版本的JS环境中。

例如，ES6定义了一个称为`Number.isNaN(..)`的工具，来为检查`NaN`值提供一种准确无误的方法，同时废弃原来的`isNaN(..)`工具。这个工具可以很容易填补，因此你可开始在你的代码中使用它，而不管最终用户是否在一个ES6浏览器中。

- return x !== x; // 在 JS 的中，**NaN 是整个语言中唯一与自己不相等的值**

#### 转译

没有任何办法可以填补语言中新增加的语法。在老版本的 JS 引擎中新的语法将因为不可识别/不合法而抛出一个错误。

所以更好的选择是使用一个工具将你的新版本代码转换为等价的老版本代码。这个处理通常被称为“转译（transpiling）”，表示转换 + 编译。

实质上，你的源代码是使用新的语法形式编写的，但是你向浏览器部署的是转译过的旧语法形式。你一般会将转译器插入到你的构建过程中，与你的代码linter和代码压缩器类似。

你可能想知道为什么要麻烦地使用新语法编写程序又将它转译为老版本代码 —— 为什么不直接编写老版本代码呢？

关于转译你应当注意几个重要的原因：

- **在语言中新加入的语法是为了使你的代码更具可读性和维护性而设计的**。老版本的等价物经常会绕多得多的圈子。你应当首选编写新的和干净的语法，不仅为你自己，也为了开发团队的其他的成员。
- 如果你仅为老版本浏览器转译，而给最新的浏览器提供新语法，那么你就可以利用浏览器对新语法进行的性能优化。这也让浏览器制造商有更多真实世界的代码来测试它们的实现和优化方法。
- 提早使用新语法可以允许它在真实世界中被测试得更加健壮，这给JavaScript委员会（TC39）提供了更早的反馈。如果问题被发现的足够早，他们就可以在那些语言设计错误变得无法挽回之前改变/修改它。

这是一个转译的简单例子。ES6增加了一个称为“默认参数值”的新特性。它看起来像是这样：

```js
function foo(a = 2) {
	console.log( a );
}

foo();		// 2
foo( 42 );	// 42
```

简单，对吧？也很有用！但是这种新语法在前ES6引擎中是不合法的。那么转译器将会对这段代码做什么才能使它在老版本环境中运行呢？

```js
function foo() {
	var a = arguments[0] !== (void 0) ? arguments[0] : 2;
	console.log( a );
}
```

如你所见，它检查`arguments[0]`值是否是`void 0`（也就是`undefined`），而且如果是，就提供默认值`2`；否则，它就赋值被传递的任何东西。

除了可以现在就在老版本浏览器中使用更好的语法以外，**观察转译后的代码实际上更清晰地解释了意图中的行为**。

如果你默认地使用一个转译器，那么你将总是可以在发现新语法有用时，立即开始使用它，而不必为了让今天的浏览器被淘汰而等上好几年。

有好几个了不起的转译器供你选择。这是一些在本书写作时存在的好选择：

- Babel ([https://babeljs.io](https://babeljs.io/)) (前身为 6to5): 将 ES6+ 转译为 ES5
- Traceur (<https://github.com/google/traceur-compiler>): 将 ES6，ES7，和以后特性转译为 ES5

### 非 JavaScript

至此，我们讨论过的所有东西都限于JS语言本身。现实是大多数JS程序都是在浏览器这样的环境中运行并与之互动的。你所编写的很大一部分代码，**严格地说，不是直接由JavaScript控制的。这听起来可能有点奇怪**。

你将会遇到的**最常见的非 JavaScript 程序是DOM API**。例如：

```js
var el = document.getElementById( "foo" );
```

**当你的代码运行在一个浏览器中时，变量`document`作为一个全局变量存在。它不是由 JS 引擎提供的，也不为JavaScript语言规范所控制。它采取了某种与普通JS `object`极其相似的形式，但它不是真正的`object`。它是一种特殊的`object`，经常被称为“宿主对象”。**

**另外，`document`上的`getElementById(..)`方法看起来像一个普通的JS函数，但它只是一个微微暴露出来的接口，指向由浏览器 DOM 提供的内建方法。在一些（新一代的）浏览器中，这一层可能也是由 JS 实现的，但是传统的 DOM 及其行为是由像C/C++这样的语言实现的。**

另一个例子是输入/输出（I/O）。

大家最喜爱的`alert(..)`在用户的浏览器窗口中弹出一个消息框。**`alert(..)`是由浏览器提供给你的 JS 程序的，而不是JS引擎本身。你进行的调用将消息发送给浏览器内部，它来处理消息框的绘制与显示。**

`console.log()`也一样；你的浏览器提供这样的机制并将它们挂在开发者工具中。

### 复习

学习 JavaScript 风格编程的第一步是对它的核心机制有一个基本的了解，比如：值，类型，函数闭包，`this`，和原型。

当然，这些话题中的每一个都会衍生出比你在这里见到的多得多的内容，这也是为什么它们在这个系列剩下的部分中拥有自己的章节和书目。在你对本章中的概念和代码示例感到相当适应之后，这个系列的其他部分正等着你真正地深入挖掘和了解这门语言。

这本书的最后一章将会对这个系列的每一卷的内容，以及它们所涵盖的我们在这里还没有探索过的概念，进行简单地总结。