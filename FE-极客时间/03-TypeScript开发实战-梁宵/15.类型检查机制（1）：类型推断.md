# 15 | 类型检查机制（1）：类型推断

[TOC]

从本节课开始我们将介绍一些 TS 的类型检查机制。

## 类型检查机制

> 类型检查机制：
>
> TypeScript 编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为。
>
> 作用：辅助开发，提高开发效率。

- 类型推断
- 类型兼容性
- 类型保护



## 类型推断

> 不需要指定变量的类型（函数的返回值类型），TS 可以根据某些规则自动地为其推断出一个类型。

- 基础类型推断
- 最佳通用类型推断
- 上下文类型推断



### 基础类型推断

基础类型推断也是 TS 中比较常见的类型推断，通常发生在以下的场景，比如在初始化一个变量时：

```ts
let a; // let a: any
let a1 = 1 // let a1: number
let b = [] // let b: any[]
let b1 = [1] // let b: number[]
```

这里我们声明一个变量 `a`，如果不指定它的变量类型，TS 会自动帮我们推断出其为 any 类型（第 1 行），如果为其赋值为 1，那么就会推断为 `number` 类型（第 2 行），如果赋值空数组字面量，则推断为以 any 类型为元素的数组类型，如果赋值为 `[1]`，则推断为以 `number` 类型为元素的数组。

还有一种情况发生在设置函数默认参数的时候：

```ts
let c = (x = 1) => {} // (parameter) x: number
```

这里定义一个函数 `c`，其有一个参数 `x` 默认为 1，这时候推断 `x` 为 `numebr` 类型。

还有在确定函数返回值的时候，也会发生类型推断：

```ts
let c = (x = 1) => x + 1 // let c: (x?: number) => number
```

这里将函数返回为 `x + 1`，那么 `c` 的返回值类型就会被推断为 `numebr` 类型。



### 类型兼容性

当需要从多个类型中推断出一个类型的时候，TS 就会尽可能的推断出一个兼容当前所有类型的通用类型，这个就是**最佳类型通用推断**，比如：

```ts
let b = [1, null] // let b: (number | null)[]
```

这里为数组 `b` 赋值为 `[1, null]` ，由于 `null` 和 `number` 不兼容，所以 `b` 就会被推断为 `number` 和 `null` 的**联合类型**。

如果我们将 `strictNullChecks` 配置项设置为 `false`：

```json
//tsconfig.json
{
  "strictNullChecks": false
}
```

那么，这个时候 `number` 和 `null` 就兼容了，`b` 就会被推断为一个 `number` 类型的数组：

```ts
let b = [1, null] // let b: number[]
```



### 上下文类型推断

以上的类型推断都是从右向左的推断，也就是根据表达式右侧的值来推断表达式左侧变量的类型。还有一种类型推断它的方向是相反的，也就是从左到右，这个就是**上下文类型推断**，它通常会发生一个事件处理中。比如：

```ts
window.onkeydown = (event) => { // (parameter) event: KeyboardEvent
  console.log(event.button) //报错：类型“KeyboardEvent”上不存在属性“button”。ts(2339)
}
```

这里我们给 `window` 绑定一个 `onkeydown` 事件，其参数为 `event`，这个时候就会发生上下文的类型推断，TS 会根据左侧的事件绑定来推断出右侧事件 `event` 的类型，比如这里被推断为 `KeyboardEvent`，同时它也知道，这个 `event` 相应的属性是什么，比如我们输入 `event.` 的时候就会自动提示出键盘事件有哪些属性和方法。如果我们打印一个 `event.button` 就会报错，因为 `button` 不是一个键盘事件的属性，它是一个鼠标事件的属性。



## 类型断言

以上就将三种类型推断介绍完了，但有时候 TS 的类型推断不符合你的预期，而且你完全有自信比 TS 了解你的代码，这个时候 TS 就提供了一种方法，允许你覆盖它的推断，这个就是**类型断言**。

在前面的课程中我们已经介绍过一些类型断言了，这里再复习一下。

```ts
interface Foo{
  bar: numebr
}

let foo = {} as Foo
foo.bar = 1
```

首先定义一个空对象 `foo`，然后给它指定一个属性，这个时候会报错，这个空对象上没有 `bar` 属性，因此我们可以先定义一个接口 `Foo`，让这个接口有一个 `bar` 属性，它的类型是 `number`，这个时候就可以使用类型断言把 `foo` 指定为 `Foo` 接口，这个时候就不会报错了。

但是我们也要注意类型断言不能乱用，比如：

```ts
interface Foo{
  bar: numebr
}

let foo = {} as Foo
//foo.bar = 1
```

这里将 `bar` 的属性赋值给注释掉，然后我们会发现没有任何的报错，其实这个时候这个对象并没有按照接口的严格约定定义一个 `bar` 属性，那么这种情况就是**遗漏**，那对于**遗漏**我们应该怎么办？所以，还是建议直接把这个对象指定为 `Foo` 接口类型：

```ts
interface Foo{
  bar: numebr
}

let foo: Foo = {}
//foo.bar = 1
```

也就是在声明的时候就要指定 `foo` 的类型。这个时候 TS 就会提示这个对象缺少一个属性。

类型断言可以增加我们代码的灵活性，在改造一些久代码的时候非常有效，但使用类型断言要注意避免乱用，你要**对上下文环境有一个充足的预判**，没有任何根据的类型断言会给程序带来安全的隐患。



## 小结

TS 的类型推断可以为我们提供重要的辅助信息，应该善加利用，你可以检查你过去使用的代码，看看哪些可以用类型推断进行优化。

下一节将介绍类型的兼容性问题。