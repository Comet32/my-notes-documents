# Z-2 作用域与闭包

[TOC]

## 1.什么是作用域

几乎所有语言的**最基础模型之一**就是**在变量中存储值**，并且**在稍后取出或修改这些值的能力**。事实上，**在变量中存储值和取出值的能力，给程序赋予了 *状态*。**

但是在我们的程序中纳入变量，引出了我们现在将要解决的最有趣的问题：这些变量 *存活* 在哪里？换句话说，它们被存储在哪儿？而且，最重要的是，我们的程序如何在需要它们的时候找到它们？

**回答这些问题需要一组明确定义的规则，它定义如何在某些位置存储变量，以及如何在稍后找到这些变量。我们称这组*规则*为：*作用域*。**

但是，这些 *作用域* 规则是在哪里、如何被设置的？

### 编译器理论

尽管 JavaScript 一般被划分到“动态”或者“解释型”语言的范畴，但是**其实它是一个编译型语言。它 *不是* 像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。**

在传统的编译型语言处理中，一块儿源代码，你的程序，在它被执行 *之前* 通常将会经历三个步骤，大致被称为“编译”：

1. **分词/词法分析：** 将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）。
2. **解析：** 将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— **A**bstract **S**yntax **T**ree）。
3. **代码生成：** 这个处理将抽象语法树转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。

和大多数其他语言的编译器一样，JavaScript 引擎要比这区区三步复杂太多了。例如，在解析和代码生成的处理中，一定会存在优化执行效率的步骤，包括压缩冗余元素，等等。

**JavaScript 引擎没有（像其他语言的编译器那样）大把的时间去优化，因为 JavaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中**。对 JavaScript 来说，在许多情况下，编译发生在代码被执行前的仅仅几微秒之内（或更少！）。

为了简单起见，我们可以说，**任何 JavaScript 代码段在它执行之前（通常是 *刚好* 在它执行之前！）都必须被编译。**

### 理解作用域

让我们见一见处理程序 `var a = 2;` 时进行互动的演员吧，这样我们就能理解稍后将要听到的它们的对话：

1. *引擎*：负责从始至终的编译和执行我们的 JavaScript 程序。
2. *编译器*：*引擎* 的朋友之一；处理所有的解析和代码生成的重活儿（见前一节）。
3. *作用域*：*引擎* 的另一个朋友；收集并维护一张所有被声明的标识符（变量）的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。

当你看到程序 `var a = 2;` 时，你很可能认为它是一个语句。但这不是我们的新朋友 *引擎* 所看到的。事实上，*引擎* 看到两个不同的语句，一个是 *编译器* 将在编译期间处理的，一个是 *引擎* 将在执行期间处理的。

对于一个变量赋值，发生了两个不同的动作：第一，*编译器* 声明一个变量（如果先前没有在当前作用域中声明过），第二，当执行时，*引擎* 在 *作用域* 中查询这个变量并给它赋值，如果找到的话。

### 编译器术语

当 *引擎* 执行 *编译器* 在第二步为它产生的代码时，它必须查询变量 `a` 来看它是否已经被声明过了，而且这个查询是咨询 *作用域* 的。但是 *引擎* 所实施的查询的类型会影响查询的结果。

在我们这个例子中，*引擎* 将会对变量 `a` 实施一个“LHS”查询。另一种类型的查询称为“RHS”。

对于我们的目的来说，一个 RHS 是难以察觉的，因为它简单地**查询某个变量的值**，而 LHS 查询是**试着找到变量容器本身**，以便它可以赋值。

**注意：** 你可能会试图将函数声明 `function foo(a) {...` 概念化为一个普通的变量声明和赋值，比如 `var foo` 和 `foo = function(a){...`。这样做会诱使你认为函数声明涉及了一次 LHS 查询。

然而，一个微妙但重要的不同是，**在这种情况下 *编译器* 在代码生成期间同时处理声明和值的定义，如此当 *引擎* 执行代码时，没有必要将一个函数值“赋予” `foo`。因此，将函数声明考虑为一个我们在这里讨论的 LHS 查询赋值是不太合适的。**

> 这里，我们需要将引擎这一概念细分，让引擎成为执行编译后代码的工具，而编译器负责编译代码，作用域负责利用规则管理变量。但如果从广义的去考虑，引擎可以包含刚刚所说的三部分。

### 嵌套的作用域

我们说过 *作用域* 是通过标识符名称查询变量的一组规则。但是，通常会有多于一个的 *作用域* 需要考虑。

就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。所以，如果在直接作用域中找不到一个变量的话，*引擎* 就会咨询下一个外层作用域，如此继续直到找到这个变量或者到达最外层作用域（也就是全局作用域）。

### 错误

为什么我们区别 LHS 和 RHS 那么重要？

**因为在变量还没有被声明（在所有被查询的 *作用域* 中都没找到）的情况下，这两种类型的查询的行为不同**。

如果 RHS 查询在嵌套的 *作用域* 的任何地方都找不到一个值，这会导致 *引擎* 抛出一个 `ReferenceError`。必须要注意的是这个错误的类型是 `ReferenceError`。

相比之下，如果 *引擎* 在进行一个 LHS 查询，但到达了顶层（全局 *作用域*）都没有找到它，而且如果程序没有运行在“Strict模式”[^note-strictmode]下，那么这个全局 *作用域* 将会在 **全局作用域中** 创建一个同名的新变量，并把它交还给 *引擎*。

现在，如果一个 RHS 查询的变量被找到了，但是你试着去做一些这个值不可能做到的事，比如将一个非函数的值作为函数运行，或者引用 `null` 或者 `undefined` 值的属性，那么 *引擎* 就会抛出一个不同种类的错误，称为 `TypeError`。

**`ReferenceError` 是关于 *作用域* 解析失败的，而 `TypeError` 暗示着 *作用域* 解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。**

### 复习

**作用域是一组规则，它决定了一个变量（标识符）在哪里和如何被查找**。这种查询也许是为了向这个变量赋值，这时变量是一个 LHS（左手边）引用，或者是为取得它的值，这时变量是一个 RHS（右手边）引用。



## 2.词法作用域

**作用域的工作方式有两种占统治地位的模型**。其中的第一种是最最常见，在绝大多数的编程语言中被使用的。它称为 **词法作用域**，我们将深入检视它。另一种仍然被一些语言（比如 Bash 脚本，Perl 中的一些模式，等等）使用的模型，称为 **动态作用域**。

### 词法分析时

词法作用域这个名称来源于标准语言编译器的第一个传统步骤**词法分析**（也就是分词）

**词法作用域是在词法分析时被定义的作用域**。换句话说，词法作用域是基于，你，在写程序时，变量和作用域的块儿在何处被编写决定的，因此**它在词法分析器处理你的代码时（基本上）是固定不变的**。

[![img](assets/fig2-1547811838159.png)

**气泡1** 包围着全局作用域，它里面只有一个标识符：`foo`。

**气泡2** 包围着作用域 `foo`，它含有三个标识符：`a`，`bar` 和 `b`。

**气泡3** 包围着作用域 `bar`，它里面只包含一个标识符：`c`。

将这些作用域考虑为套在一起的气泡可能有助于思考。

作用域气泡是根据作用域的块儿被写在何处定义的，一个嵌套在另一个内部，等等。在下一章中，我们将讨论作用域的不同单位，但是就现在来说，让我们认为**每一个函数创建了一个新的作用域气泡**。

#### 查询

**这些作用域气泡的结构和相对位置完全解释了 *引擎* 在查找一个标识符时，它需要查看的所有地方。**

**一旦找到第一个匹配，作用域查询就停止了**。相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，**向外/向上不断查找**，直到第一个匹配才停止。

**注意：** 全局变量也自动地是全局对象（在浏览器中是 `window`，等等）的属性，所以不直接通过全局变量的**词法名称**，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。如下：

```js
window.a
```

**这种技术给出了访问全局变量的方法，没有它全局变量将因为被遮蔽而不可访问**。然而，被遮蔽的非全局变量是无法**访问**的。

> 如果变量是通过 let 或者 const 声明则无法在全局对象中访问到。

不管函数是从 *哪里* 被调用的，也不论它是 *如何* 被调用的，它的词法作用域是由这个函数被声明的位置 **唯一** 定义的。

词法作用域查询 *仅仅* 在处理头等标识符时实施，比如 `a`，`b`，和 `c`。如果你在一段代码中拥有一个 `foo.bar.baz` 的引用，词法作用域查询将在查找 `foo` 标识符时实施，但一旦定位这个变量，**对象属性访问规则**将会分别接管 `bar` 和 `baz` 属性的解析。

### 欺骗词法作用域

JavaScript 有两种这样的机制。在广大的社区中它们都等同地被认为是让人皱眉头的，在你代码中使用它们是一种差劲儿的做法。但是关于它们的常见的争论经常错过了最重要的一点：**欺骗词法作用域会导致更低下的性能。**

- `eavl`
  - JavaScript 中的 `eval(..)` 函数接收一个字符串作为参数值，并将这个字符串的内容看作是好像它已经被实际编写在程序的那个位置上。换句话说，你可以用编程的方式在你编写好的代码内部生成代码，而且你可以运行这个生成的代码，就好像它在编写时就已经在那里了一样。
- `with`
  - `with` 语句接收一个对象，这个对象有0个或多个属性，并 **将这个对象视为好像它是一个完全隔离的词法作用域**，因此这个对象的属性被视为在这个“作用域”中词法定义的标识符。

如果 `eval(..)` 函数接收一个含有一个或多个声明的代码字符串，它就会修改现存的词法作用域，而 `with` 语句实际上是从你传递给它的对象中凭空制造了一个 **全新的词法作用域**。

#### 性能

JavaScript *引擎* 在编译阶段期行许多性能优化工作。**其中的一些优化原理都归结为实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符**。

但**如果 *引擎* 在代码中发现一个 `eval(..)` 或 `with`，它实质上就不得不 *假定* 自己知道的所有的标识符的位置可能是无效的，因为它不可能在词法分析时就知道你将会向`eval(..)`传递什么样的代码来修改词法作用域，或者你可能会向`with`传递的对象有什么样的内容来创建一个新的将被查询的词法作用域**。

**换句话说，悲观地看，如果 `eval(..)` 或 `with` 出现，那么它 *将* 做的几乎所有的优化都会变得没有意义，所以它就会简单地根本不做任何优化。**

你的代码几乎肯定会趋于运行的更慢，只因为你在代码的任何地方引入了一个了 `eval(..)` 或 `with`。无论 *引擎* 将在努力限制这些悲观臆测的副作用上表现得多么聪明，**都没有任何办法可以绕过这个事实：没有优化，代码就运行的更慢。**

### 复习

**词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的**。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。

在 JavaScript 中有两种机制可以“欺骗”词法作用域：`eval(..)` 和 `with`。前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。

这些机制的缺点是，它压制了 *引擎* 在作用域查询上进行编译期优化的能力，因为 *引擎* 不得不悲观地假定这样的优化是无效的。这两种特性的结果就是代码 *将* 会运行的更慢。**不要使用它们。**

## 3.函数与块儿作用域

正如我们在第二章中探索的，作用域由一系列“气泡”组成，这些“气泡”的每一个就像一个容器或篮子，标识符（变量，函数）就在它里面被声明。**这些气泡整齐地互相嵌套在一起，而且这种嵌套是在编写时定义的**。

但是到底是什么才能制造一个新气泡？只能是函数吗？JavaScript 中的其他结构可以创建作用域的气泡吗？

### 函数中的作用域

对这些问题的最常见的回答是，JavaScript 拥有基于函数的作用域。也就是，你**声明的每一个函数都为自己创建了一个气泡**，而且没有其他的结构可以创建它们自己的作用域气泡。但是就像我们一会儿将会看到的，这不完全正确。

函数作用域支持着这样的想法：所有变量都属于函数，而且贯穿整个函数始终都可以使用和重用（而且甚至可以在嵌套的作用域中访问）。**这种设计方式**可以十分有用，而且肯定可以完全利用 **JavaScript 的“动态”性质 —— 变量可以根据需要接受不同种类型的值。

### 隐藏于普通作用域

考虑一个函数的传统方式是，你声明一个函数，并在它内部添加代码。但是相反的想法也同样强大和有用：拿你所编写的代码的任意一部分，在它周围包装一个函数声明，这实质上“隐藏”了这段代码。

其实际结果是在这段代码周围创建了一个作用域气泡，这意味着现在在这段代码中的任何声明都将绑在这个新的包装函数的作用域上，而不是前一个包含它们的作用域。换句话说，你可以通过将变量和函数围在一个函数的作用域中来“隐藏”它们。

有多种原因驱使着这种基于作用域的隐藏。它们主要是由一种称为“最低权限原则”的软件设计原则引起的[^note-leastprivilege]，有时也被称为“最低授权”或“最少曝光”。这个原则规定，**在软件设计中，比如一个模块/对象的API，你应当只暴露所需要的最低限度的东西，而“隐藏”其他的一切。**

这个原则可以扩展到用哪个作用域来包含变量和函数的选择。如果所有的变量和函数都在全局作用域中，它们将理所当然地对任何嵌套的作用域来说都是可访问的。但这回违背“最少……”原则，因为你（很可能）暴露了许多你本应当保持为私有的变量和函数，而这些代码的恰当用法是不鼓励访问这些变量/函数的。

> 简单的理解就是，只暴露给应该暴露变量和函数，对于不需要暴露在外的变量和函数将其封装在函数中。

例如：

```js
function doSomething(a) {
	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

function doSomethingElse(a) {
	return a - 1;
}

var b;

doSomething( 2 ); // 15
```

在这个代码段中，变量 `b` 和函数 `doSomethingElse(..)` 很可能是 `doSomething(..)` 如何工作的“私有”细节。允许外围的作用域“访问” `b` 和 `doSomethingElse(..)` 不仅没必要而且可能是“危险的”，因为它们可能会以种种意外的方式，有意或无意地被使用，而这也许违背了 `doSomething(..)` 假设的前提条件。

一个更“恰当”的设计是讲这些私有细节隐藏在`doSomething(..)`的作用域内部，比如：

```js
function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}

	var b;

	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

doSomething( 2 ); // 15
```

现在，`b` 和 `doSomethingElse(..)` 对任何外界影响都是不可访问的，而是仅仅由 `doSomething(..)` 控制。它的功能和最终结果不受影响，但是这种设计将私有细节保持为私有的，这通常被认为是好的软件。

#### 避免冲突

将变量和函数“隐藏”在一个作用域内部的另一个好处是，避免两个同名但用处不同的标识符之间发生无意的冲突。冲突经常导致值被意外地覆盖。

