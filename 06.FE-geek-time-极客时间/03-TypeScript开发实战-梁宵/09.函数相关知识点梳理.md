# 09 | 函数相关知识点梳理

[TOC]

在前面的课程中，我们已经接触过一些 TS 的函数了，在本节课，我们将系统的梳理一下函数相关的知识点。首先，我们来看如何定义一个函数。

## 定义函数类型

定义函数一共有四种方式：

1. 使用 function 来定义：

   ```ts
   function add1(x: number, y:number){
     return x + y
   }
   ```

   在这里我们需要明确指出函数参数的类型，而函数的返回值可以通过 TS 的**类型推断**省去

2. 通过变量来定义函数类型：

   ```ts
   let add: (x: number, y: number) => number
   ```

3. 通过类型别名定义函数类型：

   ```ts
   type add3 = (x: number, y: number) => number
   ```

4. 通过接口定义函数类型：

   ```ts
   interface add4 = {
     (x: number, y: number): number
   }
   ```

注意，后三种只是函数类型的定义，并没有具体的实现，在调用之前我们需要**书写这个函数体**。

接下来，我们来看一下 TS 对函数的参数有什么要求。



## TS 中的函数参数

### 参数限制

在 JS 中对函数参数的个数是没有限制的，而在 TS 中对形参和实参必须**一一对应**，比如：

```ts
add1(1) //报错：应有 2 个参数，但获得 1 个。ts(2554)
//An argument for 'y' was not provided.
add1(1,2,3) // 报错：应有 2 个参数，但获得 3 个。ts(2554)
```

这里调用一个函数 `add1`，无论是少一个参数或者多一个参数都会报错。



### 可选参数

有些时候我们需要参数是可选的，可以传也可以不传，这就用到的**可选参数**，比如：

```ts
function add5(x: number, y?:number) {
  return y ? x + y : x
}

add5(1)
```

如上，定义一个函数 `add5`，其形参 `y` 通过 `?` 字符来定义其为可选参数，所以在调用时便可以传也可以不传。但是，需要注意的是，**可选参数必须位于必选参数之后**。比如：

```ts
function add5(x: number, y?: number, z:number) { // 报错：必选参数不能位于可选参数后。ts(1016)
  return y ? x + y + z : x + z
}
```

> 之所以不能省略，是因为函数的实参与形参是一一对应的关系， 



### 默认参数

我们也可以像 ES6 那样为参数提供一个默认值：

```ts
function add6(x: number, y = 0, z: number, q = 1) {
  return x + y + z + q
}
```

需要注意，在传参时，由于一一对应的关系，在必选参数前，默认参数是不可以省略的，如果想要获取默认参数，需要明确的传入 `undefined`，比如：

```ts
add6(1, 3) // 这里会将 3 赋值给 y，而缺少 z，q 并不会受到影响
```



### 剩余参数

以上的参数个数都是固定的，当参数不确定的时候，我们就可以使用剩余参数，这基本上和 ES6 相同，只是剩余参数的类型是以数组的形式存在，所以在定义其类型时需要定义为数组类型：

```ts
function add7(x: number, ...rest: number[]){
  return x + rest.reduce((pre, cur) => pre + cur)
}
```



### 函数重载

在静态类型中，比如 C++ 或者 Java 都有函数重载的概念，它们的含义是如果两个函数的名称相同，但是**参数个数或者参数类型不同**便实现了一个函数重载。

函数重载的**好处是不需要为了相似功能的函数选用不同的函数名称，这样增强了函数的可读性**。

在 TS 中函数重载的定义有一些不同的。比如，我们要实现这样一个重载，函数支持多个参数，如果参数都是数字，那么就返回所有参数的和，如果都是字符串，那么就返回字符串的拼接。

TS 的函数重载要求我们先定义一系列名称相同的函数声明，比如：

```ts
function add8(...rest: number[]): number;
function add8(...rest: string[]): string;
function add8(...rest: any[]): any {
  let first = rest[0];
  if(typeof first === 'string') {
    return rest.join('')
  }
  if(typeof first === 'number') {
    return rest.reduce((pre, cur) => pre + cure)
  }
}

console.log(add8(1,2,3)) // => 6
console.log(add8('a','b','c')) // => 'abc'
```

这里我们先定义了一个函数声明 `add8`，其参数为一个 number 数组，其返回类型是 number，接着定义一个名称相同的函数声明，它的参数是 string 数组，返回值类型是 string，这样一个**声明列表**就定义完成了，然后 TS 要求我们在一个**类型最宽泛**的版本中**实现这个重载**，所以我们再定一个名称相同的函数，其参数为最为宽泛的 any 数组，返回值也是 any，接着实现这个函数处理逻辑，最后调用并打印。

TS 编译器在处理重载的时候，会去查询一个重载的列表，也就是代码中 1 2 行定义的列表，并且会尝试第一个定义，如果匹配的话就使用这个函数定义，如果不匹配就接着往下查找，所以我们应该**将最容易匹配的函数定义写在最前面**。



## 小结

本节课我们梳理的一些函数知识点，包括如何去定义一个函数以及 TS 对函数参数类型、个数的要求，最后学习函数重载的定义。

下一节课将要学习 TS 中的类。



## 课后问答

这里有个疑问？ 如果这样调用会报错吗 add8(），不传递任何参数
如果不报错，为什么呢？

add8(...rest: any[]) 这样定义函数是否包含了未传参数的情况呢？

> 作者回复: 剩余参数表示参数个数不确定，不传是可以的，函数返回的是 undefined。可以加入判断 undefined 的逻辑：
>
> ```ts
> if (typeof first === 'undefined') {
>         throw new Error('No param')
> }
> ```
>
> 





































