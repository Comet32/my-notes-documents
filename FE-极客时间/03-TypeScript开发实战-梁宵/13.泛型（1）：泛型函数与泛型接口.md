# 13 | 泛型（1）：泛型函数与泛型接口

[TOC]

本节课我们来学习 TS 的一个重要概念——泛型

## 一个例子

很多时候我们希望一个函数或者一个类可以支持多种数据类型，使它们有更大的灵活性。这里先举个例子，一个打印函数：

```ts
function log(value: string): string {
  console.log(value);
  return value;
}
```

这里声明了一个打印函数，其接收一个字符串并将其打印出来，最终返回这个字符串。接下来，我们希望这个函数能够接受一个字符串数组，那么应该如何实现呢？

结合前面的课程，这里可以通过**函数重载**来实现：

```ts
function log(value: string): string;
function log(value: string[]): string[];
function log(value: any) {
  console.log(value)
  return value
}
```

我们先定义一个接收字符串变量的函数，然后再定义一个接收字符串数组的函数，最后在一个比较宽泛的版本中把它实现，其参数类型是 `any`。

当然，你也可能想到其他的方法，比如**联合类型**：

```ts
function log(value: string | string[]) : string | string[] {
  console.log(value);
  return value;
}
```

**联合类型**比**函数重载**更简便一些。

接下来，我们需要更进一步，希望这个函数可以接受任何类型的参数。实现上，从前面的函数重载中我们已经得到了答案，就是直接使用 `any` 类型：

```ts
function log(value: any) {
  console.log(value);
  return value;
}
```

到此为止，这个函数似乎满足了我们所有的需求，但是产生了另外一个问题，就是 `any` 类型丢失了一些信息，也就是类型之间的约束关系，它忽略了**输入参数的类型**和**函数返回值的类型**必须是一致的。当一个调用者看到这个函数的时候，它无法获知这种约束关系，因此，我们需要使用**泛型**来帮助我们解决这个问题。

## 什么是泛型

> 泛型：一般的、广泛的，**不预先确定的数据类型，具体的类型在使用的时候才能确定**。
>
> 可以将**使用**理解为使用类、函数、对象来实现接口或者说定义的时候。

### 使用泛型定义函数

使用泛型来改造 `log` 函数。

```ts
function log<T>(value: T): T {
  console.log(value);
  return value;
}

log<string[]>(['a','b'])
log(['a','b'])
```

- 首先，在函数的名称之后加上一对尖括号 `<>`，里面有一个变量 `T`，然后我们把参数类型和返回值类型也改为 `T`，这样一个泛型函数就形成了。改造之后，一方面类型 `T` 不需要预先的指定，就相当于 `any` 类型，另一方面它也保证了输入参数与返回值是一致的。

- 定义了泛型函数后，可以有两种调用方式：
  - 第一种是在调用的时候直接指明这个 `T` 的类型，比如可以是 `string[]`（第 6 行），然后它的参数就必须是一个字符串数组
  - 第二种方式就是可以利用 TS 的类型推断省略类型的参数（第 7 行）直接传入数组，这也是比较推荐的方式。



### 使用泛型定义函数类型

我们不仅可以用泛型来定义一个函数，也可以定义一个函数类型：

```ts
type Log = <T>(value: T) => T
let myLog: Log = log
```

这里使用**类型别名**定义一个泛型函数类型，后面和函数签名的格式差不多，只不过我们需要将函数的名称去掉。接着我们定义一个变量，其类型为 `Log`，而具体的实现可以指定为上面声明的函数 `log`，这样就完成了一个泛型函数的实现。



## 泛型接口

泛型可以用在接口中，我们仍然使用上面的例子

```ts
interface Log {
  <T>(value: T): T
}
```

这里我们使用一个接口的定义方式，接口的名称叫 `Log`，接口属性的描述和上面函数声明差不多，同样也去掉函数名称，然后是 `T` 和参数类型、返回值类型。这样就和函数别名的方式就完全等价了。

在这里，泛型仅仅约束了一个函数，我们也可以用泛型来约束接口的其他成员，方法就是将**泛型变量**（类型参数）放到接口名称的后面，这样接口的**所有成员都可以受到泛型变量的约束了**：

```ts
interface Log<T> {
  (value: T) : T
}
```

需要注意一点，当泛型变量约束了整个接口之后，在**实现时我们必须指定一个类型**：

```ts
let myLog: Log = log // 报错：泛型类型“Log<T>”需要 1 个类型参数。ts(2314)、

let myLog: Log<number> = log 
```

这里定义一个 `myLog`，其类型为 `Log`，如果直接指定 log 函数会提示：*泛型类型“Log<T>”需要 1 个**类型参数**。ts(2314)*，所以在第 3 行，我们给 `log` 函数指定一个 `number` 类型，那么 `myLog` 的参数和返回值就只能是 `number`。

如果不指定类型，我们也可以在接口的定义中指定一个默认的类型：

```ts
interface Log<T = string> {
  (value: T) : T
}

let myLog: Log = log
myLog('a')
```

这里我们将接口的泛型变量默认设置为 `string`，之后在声明 `myLog` 时对于类型 `Log` 就可以不用在传入一个类型参数，而默认为 `string`。



## 小结

本节课学习了泛型，泛型对前端开发来说是一个比较新的概念，可能刚刚开始接触难以理解，这里有一个方法，就是把泛型变量和函数的参数等同对待，它只不过**是另一个维度的参数，是代表类型而不是代表值的参数**。泛型在后面高级类型中有广泛的应用，建议在本节开始打下一个良好的基础。

下一节将介绍泛型类和泛型约束。



## 课后问答

老师，下面两种的区别
```ts
type Log = <T>(value: T) => T;
type Log<T> = (value: T) => T;
```
或者
```ts
interface Log {
  <T>(value: T):T
}

interface Log<T> {
  (value: T):T
}
```

> 作者回复: 1、3是等价的，使用时无需指定类型：
> `let log: Log = ...`
>
> 2、4是等价的，使用时必须指定类型
> `let log: Log<number> = ...`













