#  22 | ES6与CommonJS的模块系统

[TOC]

本节课我们正式进入**工程篇**的学习。

随着前端应用越来越复杂，多人协作开发成为了一种常态，而模块化的开发方式也被广泛接受了，然而这是一个渐进的过程，在这个过程中曾经诞生过许多模块化的解决方案，比如说 CommonJS、AMD、CMD 等等。

经历了时间的沉淀，最终我们最为常用的两种方案是 ES6 模块和 CommonJS 模块。TS 对这两种模块系统都有比较好的支持，本节课首先会回顾一下两种模块系统，然后再对比它们之间的兼容性问题。

## ES6 模块化系统

在 `typescript-in-action` 项目中的 `sourcecode/ts-base/src/part2.project/01.module/es6` 目录下有三个模块 `a.ts` `b.ts` `c.ts` ，它们之间的依赖关系是，`c.ts` 依赖了 `a.ts` ，然后 `a.ts` 又依赖了 `b.ts` ，所以为了看出最后的执行效果，我们在 `index.ts` 中直接引入进来：

```ts
import './es6/c'
```

接下来我们先来看一下 ES6 的模块导出。

### 模块导出

打开 `a.ts` 文件：

```ts
// 单独导出
export let a = 1

// 批量导出
let b = 2
let c = 3
export { b, c }

// 导出接口
export interface P {
    x: number;
    y: number;
}

// 导出函数
export function f() {}

// 导出时起别名
function g() {}
export { g as G }

// 默认导出，无需函数名
export default function () {
    console.log("I'm default")
}

// 引入外部模块，重新导出
export { str as hello } from './b'
```

ES6 的导出通过 `export` 语句实现

- 可以单独的导出一个变量（第 2 行）
- 也可以将多个变量放在一个对象中批量导出（第 5 ～ 7 行）
- 在 TS 中 ES6 也可以单独的导出一个接口（第 10 ～ 13 行）
- 当然也可以直接导出一个函数（第 16 行）

- 另外，在导出的时候可以给一个变量起一个别名（第 19 ～ 20 行），这里为 `g` 函数起了一个 `G` 的别名
- 也可以有默认的导出，也就是 `export default` ，默认导出时函数是不用起名的，如果起了名字也可以，但是在导入的时候是无效的（第 23 行）
- 最后，ES6 也可以引入外部的模块重新的导出（第 28 行），比如在这里引入了 b 模块 

看一下 b 模块：

```ts
// 导出常量
export const str = 'Hello'
```

在 b 模块中直接导出了一个常量 `str` ，然后在 a 模块中给 `str` 起了一个别名 `hello` ，然后再重新导出。

这些就是 ES6 的导出。

### 模块导入

c.ts 模块：

```ts
import { a, b, c } from './a'; // 批量导入
import { P } from './a';       // 导入接口
import { f as F } from './a';  // 导入时起别名
import * as All from './a';    // 导入模块中的所有成员，绑定在 All 上
import myFunction from './a';  // 不加{}，导入默认

console.log(a, b, c) // 1 2 3

let p: P = {
    x: 1,
    y: 1
}

console.log(All) // {a: 1, b:2, c:3, f: f. G: f, default: f, ...}

myFunction() // I'm default
```

导入的时候：

- 可以通过 `{}` 的形式批量的导入（1）
- 也可以导入一个接口，这个接口就可以约束这个模块中的变量（2）
- 也可以起别名，比如将 a 模块中导出的 `f` 起一个别名 `F` （3）
- 可以用 `* as 变量名` 导出模块中的所有成员，并且将所有的成员绑定在这个变量上（4）。这里我们将变量 `All` 打印出来，可以看到这个变量 `All` 包含了所有 `a` 模块中导出的变量，这里需要注意 TS 在 `All` 中加入了一个 `default` 属性，这个在后面会详细的介绍。
- 可以使用默认的导入，也就是不加任何的 `{}` ，默认导入是一个 `function` ，我们可以直接执行。（5）

那么，ES6 的模块我们就简单的回顾到这儿。

接下来，我们回顾一下 CommonJS 模块。

## CommonJS 

node 是 CommonJS 的一种实现。我们在 `sourcecode/ts-base/src/part2.project/01.module` 目录中创建了一个 `node` 文件夹，里面有三个模块 `a.node.ts` `b.node.ts` `c.node.ts` ，它们之间的依赖关系是 `c.node.ts` 依赖了 `a` 和 `b` 。我们先来看一下 node 模块的导出。

### 导出模块

a.node.ts 文件：

```ts
let a = {
    x: 1,
    y: 2
}

// 整体导出
module.exports = a
```

node 模块的导出可以把这个模块中所有的变量作为一个整体导出，它使用 `module.exports = a` 这样的语法，也就是用 `exports.` 这样的语法导出多个变量，比如 b 模块中：

```ts
// exports === module.exports
// 导出多个变量
// module.exports = {}
exports.c = 3
exports.d = 4
```

其实这个 `exports` 就是 `module.exports` 的引用。

node 模块的导出比较简单。接下来我们看一下它的导入。

### 导入模块

c.node.ts 文件：

```ts
let c1 = require('./a.node')
let c2 = require('./b.node')
let c3 = require('../es6/a')
import c4 = require('../es6/d')

console.log(c1) // { x: 1, y: 2}
console.log(c2) // { c: 3, d: 4}
// c3()
// console.log(c3)
// c3.default()
c4()
```

导入也比较简单，直接使用 `require` 语句就可以了。接着我们打印一下导出的模块 `c1` 和 `c2` ，因为我们这里编写的 node 模块，所以我们希望它在 node 环境下运行，使用 `node` 命令执行一下：

```shell
node ./sourcecode/ts-base/src/part2.project/01.module/node/c.node.ts
```

这个时候会报错：`Cannot find module './a.node'` ，因为 nodeJS 是默认去寻找 js 文件的，所以 node 不能直接执行 ts 文件，我们需要将这个 ts 文件编译为 js 文件才可以用 node 命令执行，但这样很麻烦，我们可以通过安装一个工具来实现直接运行 ts 文件，这个工具叫 ts-node，安装：

```ts
npm i ts-node -g
```

安装好之后我们就可以直接用 `ts-node` 执行 .ts 文件了：

```shell
ts-node ./sourcecode/ts-base/src/part2.project/01.module/node/c.node.ts
```

然后我们就可以在控制台看到打印和运行结果了：

```shell
$ ts-node ./sourcecode/ts-base/src/part2.project/01.module/node/c.node.ts
{ x: 1, y: 2 }
{ c: 3, d: 4 }
I'm default
```



好的，两个模块系统我们就简单的回顾到这里，可以看到 TS 对两个模块系统都能有比较好的支持，以上我们都是在开发环境下运行的，那在生产环境中两个模块系统会被构建成什么样呢？

